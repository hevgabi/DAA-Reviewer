<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IT1809 ‚Äî Algorithm Reviewer</title>
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --card: #1a1a26;
    --border: #2a2a40;
    --accent: #7c3aed;
    --accent2: #06b6d4;
    --accent3: #f59e0b;
    --green: #10b981;
    --red: #ef4444;
    --text: #e2e8f0;
    --muted: #94a3b8;
    --white: #ffffff;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* BG grid */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(124,58,237,0.04) 1px, transparent 1px),
      linear-gradient(90deg, rgba(124,58,237,0.04) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 1.5rem 4rem;
  }

  /* HEADER */
  header {
    text-align: center;
    margin-bottom: 3rem;
    padding: 2.5rem 1rem;
    border: 1px solid var(--border);
    background: var(--surface);
    position: relative;
    overflow: hidden;
  }
  header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(ellipse at center, rgba(124,58,237,0.12) 0%, transparent 60%);
    pointer-events: none;
  }
  .badge {
    display: inline-block;
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--accent2);
    border: 1px solid var(--accent2);
    padding: 0.3rem 0.8rem;
    margin-bottom: 1rem;
  }
  h1 {
    font-family: 'Syne', sans-serif;
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 800;
    line-height: 1.1;
    background: linear-gradient(135deg, var(--white) 0%, var(--accent2) 50%, var(--accent) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .subtitle {
    margin-top: 0.75rem;
    color: var(--muted);
    font-size: 0.8rem;
    letter-spacing: 0.05em;
  }

  /* SCORE BAR */
  .score-bar {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }
  .score-pill {
    flex: 1;
    min-width: 120px;
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 1rem;
    text-align: center;
  }
  .score-pill .val {
    font-family: 'Syne', sans-serif;
    font-size: 1.8rem;
    font-weight: 800;
    color: var(--accent2);
  }
  .score-pill .lbl {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--muted);
    margin-top: 0.2rem;
  }

  /* TABS */
  .tabs {
    display: flex;
    gap: 0;
    margin-bottom: 2rem;
    border: 1px solid var(--border);
    overflow: hidden;
    flex-wrap: wrap;
  }
  .tab-btn {
    flex: 1;
    min-width: 100px;
    background: var(--surface);
    color: var(--muted);
    border: none;
    border-right: 1px solid var(--border);
    padding: 0.75rem 0.5rem;
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.2s;
  }
  .tab-btn:last-child { border-right: none; }
  .tab-btn.active {
    background: var(--accent);
    color: var(--white);
  }
  .tab-btn:hover:not(.active) {
    background: var(--card);
    color: var(--text);
  }

  /* SECTIONS */
  .section { display: none; }
  .section.active { display: block; }

  /* GLOSSARY */
  .glossary-grid {
    display: grid;
    gap: 1rem;
  }
  .term-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    padding: 1.25rem;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
  }
  .term-card:hover { border-color: var(--accent); background: #1e1e2e; }
  .term-card .term-name {
    font-family: 'Syne', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    color: var(--accent2);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .term-card .term-tag {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--accent3);
    border: 1px solid var(--accent3);
    padding: 0.15rem 0.4rem;
    font-family: 'Space Mono', monospace;
  }
  .term-card .term-def {
    margin-top: 0.75rem;
    color: var(--muted);
    font-size: 0.8rem;
    line-height: 1.7;
    display: none;
  }
  .term-card.open .term-def { display: block; }
  .term-card .term-example {
    margin-top: 0.75rem;
    background: var(--bg);
    border-left: 2px solid var(--accent3);
    padding: 0.75rem;
    font-size: 0.75rem;
    color: var(--accent3);
    font-style: italic;
    line-height: 1.6;
  }
  .toggle-icon {
    font-size: 1.2rem;
    color: var(--accent);
    transition: transform 0.2s;
  }
  .term-card.open .toggle-icon { transform: rotate(45deg); }

  /* CATEGORY HEADER */
  .cat-header {
    font-family: 'Syne', sans-serif;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: var(--accent);
    border-bottom: 1px solid var(--border);
    padding-bottom: 0.5rem;
    margin: 2rem 0 1rem;
  }

  /* FLASHCARD */
  .flashcard-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
  }
  .progress-bar-outer {
    width: 100%;
    height: 4px;
    background: var(--border);
  }
  .progress-bar-inner {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.4s ease;
  }
  .card-count {
    font-size: 0.7rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    align-self: flex-end;
  }
  .flashcard {
    width: 100%;
    min-height: 260px;
    perspective: 1000px;
    cursor: pointer;
  }
  .card-inner {
    position: relative;
    width: 100%;
    min-height: 260px;
    transition: transform 0.6s cubic-bezier(0.4,0,0.2,1);
    transform-style: preserve-3d;
  }
  .flashcard.flipped .card-inner { transform: rotateY(180deg); }
  .card-face {
    position: absolute;
    inset: 0;
    backface-visibility: hidden;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 2rem;
    text-align: center;
    border: 1px solid var(--border);
  }
  .card-front {
    background: var(--card);
    border-top: 3px solid var(--accent);
  }
  .card-back {
    background: #0f0f1a;
    border-top: 3px solid var(--accent2);
    transform: rotateY(180deg);
  }
  .card-front .q-label {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: var(--accent);
    margin-bottom: 1rem;
  }
  .card-front .q-text {
    font-family: 'Syne', sans-serif;
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--white);
    line-height: 1.4;
  }
  .card-front .hint {
    margin-top: 1.5rem;
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 0.1em;
  }
  .card-back .a-label {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: var(--accent2);
    margin-bottom: 1rem;
  }
  .card-back .a-text {
    font-size: 0.85rem;
    color: var(--text);
    line-height: 1.7;
    max-width: 500px;
  }
  .card-nav {
    display: flex;
    gap: 1rem;
    width: 100%;
    justify-content: center;
    flex-wrap: wrap;
  }
  .btn {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    padding: 0.75rem 1.5rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  .btn:hover { background: var(--card); border-color: var(--accent); color: var(--accent2); }
  .btn.primary { background: var(--accent); border-color: var(--accent); color: var(--white); }
  .btn.primary:hover { background: #6d28d9; }
  .btn.success { background: var(--green); border-color: var(--green); color: var(--white); }
  .btn.danger { background: var(--red); border-color: var(--red); color: var(--white); }

  /* QUIZ */
  .quiz-q {
    background: var(--card);
    border: 1px solid var(--border);
    border-top: 3px solid var(--accent3);
    padding: 1.75rem;
    margin-bottom: 1.5rem;
  }
  .quiz-q .q-num {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: var(--accent3);
    margin-bottom: 0.75rem;
  }
  .quiz-q .q-text {
    font-family: 'Syne', sans-serif;
    font-size: 1.05rem;
    font-weight: 700;
    color: var(--white);
    margin-bottom: 1.25rem;
    line-height: 1.5;
  }
  .options {
    display: grid;
    gap: 0.6rem;
  }
  .option-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 0.85rem 1rem;
    text-align: left;
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.2s;
    line-height: 1.5;
  }
  .option-btn:hover:not(:disabled) { background: var(--card); border-color: var(--accent2); color: var(--accent2); }
  .option-btn.correct { background: rgba(16,185,129,0.15); border-color: var(--green); color: var(--green); }
  .option-btn.wrong { background: rgba(239,68,68,0.15); border-color: var(--red); color: var(--red); }
  .option-btn:disabled { cursor: default; }
  .feedback-box {
    margin-top: 0.75rem;
    padding: 0.75rem;
    font-size: 0.75rem;
    line-height: 1.6;
    display: none;
  }
  .feedback-box.show { display: block; }
  .feedback-box.ok { background: rgba(16,185,129,0.1); border-left: 3px solid var(--green); color: var(--green); }
  .feedback-box.bad { background: rgba(239,68,68,0.1); border-left: 3px solid var(--red); color: #fca5a5; }

  .quiz-submit-area { text-align: center; margin-top: 2rem; }
  .result-box {
    background: var(--card);
    border: 1px solid var(--border);
    padding: 2rem;
    text-align: center;
    display: none;
    margin-top: 2rem;
  }
  .result-box.show { display: block; }
  .result-box .big-score {
    font-family: 'Syne', sans-serif;
    font-size: 3.5rem;
    font-weight: 800;
    background: linear-gradient(135deg, var(--accent2), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .result-box .verdict {
    font-size: 0.9rem;
    color: var(--text);
    margin-top: 0.5rem;
  }
  .result-box .verdict-msg {
    font-size: 0.75rem;
    color: var(--muted);
    margin-top: 0.5rem;
  }

  /* MATCHING */
  .match-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
  }
  .match-col-label {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--muted);
    margin-bottom: 0.75rem;
  }
  .match-item {
    background: var(--card);
    border: 1px solid var(--border);
    padding: 0.85rem;
    cursor: pointer;
    font-size: 0.75rem;
    line-height: 1.5;
    transition: all 0.2s;
    margin-bottom: 0.5rem;
    user-select: none;
  }
  .match-item.selected { border-color: var(--accent2); background: rgba(6,182,212,0.1); color: var(--accent2); }
  .match-item.matched-ok { border-color: var(--green); background: rgba(16,185,129,0.1); color: var(--green); pointer-events: none; }
  .match-item.matched-bad { border-color: var(--red); background: rgba(239,68,68,0.1); color: var(--red); }

  @media(max-width: 600px) {
    .match-grid { grid-template-columns: 1fr; }
  }

  /* CHEATSHEET */
  .cheat-section {
    background: var(--card);
    border: 1px solid var(--border);
    margin-bottom: 1rem;
    overflow: hidden;
  }
  .cheat-header {
    padding: 1rem 1.25rem;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 0.9rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-left: 3px solid var(--accent2);
  }
  .cheat-header:hover { background: #1e1e2e; }
  .cheat-body {
    display: none;
    padding: 0 1.25rem 1.25rem;
  }
  .cheat-body.open { display: block; }
  .cheat-row {
    display: grid;
    grid-template-columns: 200px 1fr;
    gap: 1rem;
    padding: 0.6rem 0;
    border-bottom: 1px solid var(--border);
    font-size: 0.75rem;
    line-height: 1.6;
  }
  .cheat-row:last-child { border-bottom: none; }
  .cheat-row .key { color: var(--accent2); font-weight: 700; }
  .cheat-row .val { color: var(--muted); }

  @media(max-width: 500px) {
    .cheat-row { grid-template-columns: 1fr; gap: 0.25rem; }
  }

  /* ANIMATIONS */
  @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
  .section.active { animation: fadeIn 0.3s ease; }
</style>
</head>
<body>
<div class="container">

  <header>
    <div class="badge">IT1809 ¬∑ Exam Reviewer</div>
    <h1>Algorithm<br>Design & Analysis</h1>
    <p class="subtitle">Interactive Study Tool ¬∑ Handout 01</p>
  </header>

  <!-- SCORE BAR -->
  <div class="score-bar">
    <div class="score-pill">
      <div class="val" id="stat-terms">38</div>
      <div class="lbl">Terms</div>
    </div>
    <div class="score-pill">
      <div class="val" id="stat-quiz">0/10</div>
      <div class="lbl">Quiz Score</div>
    </div>
    <div class="score-pill">
      <div class="val" id="stat-cards">0</div>
      <div class="lbl">Cards Done</div>
    </div>
  </div>

  <!-- TABS -->
  <div class="tabs">
    <button class="tab-btn active" onclick="switchTab('glossary')">üìñ Glossary</button>
    <button class="tab-btn" onclick="switchTab('flashcards')">üÉè Flashcards</button>
    <button class="tab-btn" onclick="switchTab('quiz')">üß† Quiz</button>
    <button class="tab-btn" onclick="switchTab('match')">üîó Match</button>
    <button class="tab-btn" onclick="switchTab('cheat')">üìã Cheat Sheet</button>
  </div>

  <!-- GLOSSARY -->
  <div id="sec-glossary" class="section active">
    <div id="glossary-content"></div>
  </div>

  <!-- FLASHCARDS -->
  <div id="sec-flashcards" class="section">
    <div class="flashcard-wrap">
      <div class="progress-bar-outer"><div class="progress-bar-inner" id="fc-progress" style="width:0%"></div></div>
      <div class="card-count" id="fc-count">Card 1 of 20</div>
      <div class="flashcard" id="flashcard" onclick="flipCard()">
        <div class="card-inner" id="card-inner">
          <div class="card-face card-front">
            <div class="q-label">Term</div>
            <div class="q-text" id="fc-front"></div>
            <div class="hint">click to reveal definition</div>
          </div>
          <div class="card-face card-back">
            <div class="a-label">Definition</div>
            <div class="a-text" id="fc-back"></div>
          </div>
        </div>
      </div>
      <div class="card-nav">
        <button class="btn" onclick="prevCard()">‚Üê Prev</button>
        <button class="btn danger" onclick="markCard(false)">‚úó Still Learning</button>
        <button class="btn success" onclick="markCard(true)">‚úì Got It</button>
        <button class="btn" onclick="nextCard()">Next ‚Üí</button>
      </div>
      <button class="btn" onclick="shuffleCards()">üîÄ Shuffle Deck</button>
    </div>
  </div>

  <!-- QUIZ -->
  <div id="sec-quiz" class="section">
    <div id="quiz-content"></div>
    <div class="quiz-submit-area">
      <button class="btn primary" id="quiz-submit-btn" onclick="submitQuiz()">Submit Quiz</button>
    </div>
    <div class="result-box" id="quiz-result">
      <div class="big-score" id="quiz-score-display"></div>
      <div class="verdict" id="quiz-verdict"></div>
      <div class="verdict-msg" id="quiz-msg"></div>
      <br>
      <button class="btn primary" onclick="resetQuiz()">Try Again</button>
    </div>
  </div>

  <!-- MATCH -->
  <div id="sec-match" class="section">
    <p style="font-size:0.75rem;color:var(--muted);margin-bottom:1.5rem;">Match each term on the left with its correct definition on the right. Click a term, then click its match.</p>
    <div class="match-grid">
      <div>
        <div class="match-col-label">Terms</div>
        <div id="match-terms"></div>
      </div>
      <div>
        <div class="match-col-label">Definitions</div>
        <div id="match-defs"></div>
      </div>
    </div>
    <div style="text-align:center;margin-top:1rem;">
      <div id="match-score" style="font-family:'Syne',sans-serif;font-size:1.2rem;font-weight:700;color:var(--accent2);margin-bottom:1rem;"></div>
      <button class="btn primary" onclick="resetMatch()">üîÄ New Round</button>
    </div>
  </div>

  <!-- CHEAT SHEET -->
  <div id="sec-cheat" class="section">
    <div id="cheat-content"></div>
  </div>

</div>

<script>
// ===================== DATA =====================
const glossaryData = [
  {
    cat: "Core Concepts",
    color: "#7c3aed",
    terms: [
      { term: "Algorithm", tag: "Foundation", def: "A finite and detailed step-by-step set of instructions performed to complete a specific task.", example: "E.g., Making a sandwich, performing long division, or installing a motherboard." },
      { term: "Algorithmics", tag: "Field", def: "The design and analysis of computer algorithms. Design = method/math behind the algorithm. Analysis = determining its computational complexity.", example: "" },
      { term: "al-Khwarizmi", tag: "Origin", def: "Persian mathematician (early 9th century) from whose name the word 'algorithm' derives. Sometimes called the 'grandfather of computer science.'", example: "" },
      { term: "Pseudocode", tag: "Representation", def: "A generic way of describing an algorithm without using any specific programming language notations. 'Pseudo' = imitation, 'code' = programming instructions.", example: "E.g., if want burger then / order burger" },
      { term: "Flowchart", tag: "Representation", def: "A method of expressing an algorithm using connected geometric shapes, symbols, lines, and directional arrows showing the order of steps.", example: "Uses shapes like ovals (start/end), rectangles (process), diamonds (decision)." },
    ]
  },
  {
    cat: "5 Properties of an Algorithm",
    color: "#06b6d4",
    terms: [
      { term: "Input Specification", tag: "Property 1", def: "The inputs must be clearly identified. An algorithm can have zero or more inputs taken from a specified set of objects.", example: "For area of a square: input = length of one side (positive real number)." },
      { term: "Output Specification", tag: "Property 2", def: "The output and its relationship to inputs must be clearly identified. An algorithm must have at least one output.", example: "For rectangle area: output = height √ó width." },
      { term: "Definiteness", tag: "Property 3", def: "Steps must be precisely and unambiguously defined for every case. No vague or unclear instructions.", example: "" },
      { term: "Finiteness", tag: "Property 4", def: "The algorithm must always end after a finite number of steps using a finite amount of resources.", example: "No infinite loops; must terminate with a result." },
      { term: "Effectiveness", tag: "Property 5", def: "All operations must be sufficiently basic to be done exactly and in finite time. Instructions must be well-defined and performable.", example: "X = 1/Y + 1/Z is effective because the value can be determined in finite time." },
    ]
  },
  {
    cat: "Algorithm Design Process (6 Phases)",
    color: "#f59e0b",
    terms: [
      { term: "Phase 1: Understanding the Problem", tag: "Phase", def: "Completely read the problem, identify given data, needs, and boundaries before designing any algorithm.", example: "Ask: What input data? What formulas? What output? What constraints?" },
      { term: "Phase 2: Deciding on Computational Device & Data Structures", tag: "Phase", def: "Choose the appropriate device, data structures, and algorithm design technique (exact vs approximate).", example: "" },
      { term: "Exact Problem Solving", tag: "Technique", def: "Procedures that produce a quantifiable and definite end result.", example: "Calculating the exact square root of 4 = 2." },
      { term: "Approximate Problem Solving", tag: "Technique", def: "Procedures that produce a near-result because some problems cannot be solved exactly.", example: "Computing œÄ to many decimal places." },
      { term: "Phase 3: Designing Algorithm & Data Structure", tag: "Phase", def: "Choose proper data structures and design the algorithm. Bad data structure choice causes poor system performance.", example: "" },
      { term: "Phase 4: Proving Correctness", tag: "Phase", def: "An algorithm is correct if for every input instance, it ends with the correct output. Uses mathematical induction as a common proof technique.", example: "One failing input is enough to prove an algorithm incorrect." },
      { term: "Phase 5: Analyzing the Algorithm", tag: "Phase", def: "Measure performance considering: Efficiency (time & space), Simplicity, and Generality.", example: "" },
      { term: "Phase 6: Coding the Program", tag: "Phase", def: "Implement the algorithm as a program. Validity established through testing and debugging.", example: "" },
    ]
  },
  {
    cat: "Algorithm Design Techniques",
    color: "#10b981",
    terms: [
      { term: "Brute Force", tag: "Technique", def: "A straightforward approach based on the problem's statement and definitions. Easiest to apply; useful for small-size problem instances.", example: "Trying all possible combinations to find a password." },
      { term: "Divide and Conquer", tag: "Technique", def: "Break a problem into smaller subproblems, conquer each recursively, then combine solutions. Subproblems are normally similar to the original.", example: "Merge sort: divide array in half, sort each half, then merge." },
      { term: "Space Efficiency (Space Complexity)", tag: "Analysis", def: "The amount of memory required by an algorithm to run the application.", example: "" },
      { term: "Time Efficiency (Time Complexity)", tag: "Analysis", def: "How fast an algorithm is processed; measures the running time of an algorithm.", example: "" },
      { term: "Simplicity", tag: "Quality", def: "Simpler algorithms are easier to understand, program, and debug. Sometimes simpler = more efficient.", example: "" },
      { term: "Generality", tag: "Quality", def: "Concerns the range of problems and inputs the algorithm can handle. Broader is often better.", example: "" },
    ]
  },
  {
    cat: "Data Structures",
    color: "#ec4899",
    terms: [
      { term: "Array", tag: "Linear DS", def: "A data structure with a fixed number of components all of the same data type. Elements accessed via index (0 to n-1). Less memory than linked list.", example: "int arr[5] = {1,2,3,4,5}; accessed by arr[0]=1, arr[4]=5." },
      { term: "Linked List", tag: "Linear DS", def: "A dynamic data structure where elements (nodes) are linked via pointers. Each node has Data and a Link (pointer) to next node.", example: "Self-referential structures‚Äîeach node points to another node of same type." },
      { term: "Singly Linked List", tag: "Linked List", def: "Each node (except the last) has a single pointer to the next element. Supports insertion, deletion, traversal, search.", example: "Use when data grows dynamically and constant-time insertion/deletion is needed." },
      { term: "Doubly Linked List", tag: "Linked List", def: "Each node (except first/last) has pointers to both successor and predecessor. Can be iterated in reverse without recursion.", example: "Easier deletion; faster insert/remove." },
      { term: "Circularly Linked List", tag: "Linked List", def: "The last node's link points back to the first node of the list.", example: "Used for: buffer memory, card games, browser Back button cache, MRU list, Undo in Word/Photoshop." },
      { term: "Graph Data Structure", tag: "Non-linear DS", def: "A collection of nodes (vertices) and line segments (edges/arcs). Used for networks, shortest paths, maze solving.", example: "" },
      { term: "Directed Graph (Digraph)", tag: "Graph", def: "A graph where each line has a direction (arrowhead) to its successor. Lines called 'arcs.' Flow follows direction only.", example: "Road networks with one-way streets." },
      { term: "Undirected Graph", tag: "Graph", def: "A graph with no direction on any edges. Flow between two vertices can go either way.", example: "Social network friendships." },
      { term: "Tree Data Structure", tag: "Non-linear DS", def: "A finite set of elements (nodes) and directed lines (branches). Hierarchical structure.", example: "" },
      { term: "Binary Tree", tag: "Tree", def: "A tree where no node can have more than two subtrees (left and right). Used in phone book lookup and sorted traversal.", example: "" },
      { term: "Binary Search Tree (BST)", tag: "Tree", def: "Right node values ‚â• root; left node values < root. Memory-efficient; useful for sorted data and range searches.", example: "" },
      { term: "AVL Tree", tag: "Tree", def: "BST with balance factor. Height never exceeds O(log n). Good for fast element lookup.", example: "" },
      { term: "Heap Tree", tag: "Tree", def: "Complete/nearly complete binary tree where each node's key ‚â• its descendants. Used for priority queues and quick max/min access.", example: "" },
    ]
  },
  {
    cat: "Tree Terminology",
    color: "#8b5cf6",
    terms: [
      { term: "Root", tag: "Tree Term", def: "The first (topmost) node of the tree.", example: "" },
      { term: "Leaf", tag: "Tree Term", def: "Any node with an outdegree of zero (no children).", example: "" },
      { term: "Internal Node", tag: "Tree Term", def: "A node that is neither a root nor a leaf‚Äîfound in the middle of a tree.", example: "" },
      { term: "Degree", tag: "Tree Term", def: "The number of branches associated with a node.", example: "" },
      { term: "Indegree", tag: "Tree Term", def: "The branch directed toward a node.", example: "" },
      { term: "Outdegree", tag: "Tree Term", def: "The branch directed away from a node.", example: "" },
      { term: "Height of a Tree", tag: "Tree Term", def: "The level of the leaf in the longest path from root plus 1.", example: "" },
      { term: "Subtree", tag: "Tree Term", def: "Any connected structure below the root.", example: "" },
    ]
  },
  {
    cat: "Problem Types",
    color: "#f97316",
    terms: [
      { term: "Sorting Problem", tag: "Problem Type", def: "Rearranges items in a list in ascending order (numbers, characters, strings). Optimizes other algorithms like search and merge.", example: "Used in: student records, library holdings, employee records." },
      { term: "Searching Problem", tag: "Problem Type", def: "Finds a given value (search key) in a list. Linear search: one-by-one. Binary search: faster for large sorted arrays.", example: "Used in: student records, inventory items, company databases." },
      { term: "Linear Search", tag: "Search", def: "Examines data objects one by one sequentially.", example: "" },
      { term: "Binary Search", tag: "Search", def: "Faster search strategy for large sorted arrays using divide and conquer.", example: "" },
      { term: "String Processing Problem", tag: "Problem Type", def: "Deals with non-numerical data. A string is a sequence of characters from an alphabet (text, bit, gene sequences).", example: "Types: text strings (letters/numbers/special), bit strings (0s and 1s), gene sequences {A,C,G,T}." },
      { term: "Graph Problem", tag: "Problem Type", def: "Deals with objects and connections: determining connectivity, visiting locations, or finding shortest paths.", example: "Applications: transportation, communication, social networks, scheduling, games." },
      { term: "BFS (Breadth First Search)", tag: "Graph Algorithm", def: "Traverses from a source node layer by layer, exploring all direct neighbors first before moving deeper.", example: "" },
      { term: "DFS (Depth First Search)", tag: "Graph Algorithm", def: "Recursive traversal using backtracking‚Äîgoes deep along one path until no unvisited nodes, then backtracks.", example: "" },
      { term: "Combinatorial Problems", tag: "Problem Type", def: "The most difficult computing problems; find a combination (permutation, subset) satisfying constraints.", example: "TSP, graph coloring." },
      { term: "Traveling Salesman Problem (TSP)", tag: "Combinatorial", def: "Find the shortest tour through n cities that visits every city exactly once.", example: "Used in: route planning, circuit board fabrication, X-ray crystallography." },
      { term: "Graph-Coloring Problem", tag: "Combinatorial", def: "Assign the smallest number of colors to vertices so no two adjacent vertices share a color.", example: "Used in: event scheduling (events = vertices; edges = conflicts)." },
      { term: "Geometrical Problems", tag: "Problem Type", def: "Deals with geometric objects (points, lines, polygons). Used in computer graphics, robotics, tomography.", example: "Closest-pair problem, Convex-hull problem." },
      { term: "Closest-Pair Problem", tag: "Geometry", def: "Given n points in a plane, find the two points closest to each other.", example: "" },
      { term: "Convex-Hull Problem", tag: "Geometry", def: "Find the smallest convex polygon that would include all points of a given set.", example: "" },
      { term: "Numerical Problems", tag: "Problem Type", def: "Involves mathematical objects of continuous nature: solving equations, computing integrals, evaluating functions.", example: "" },
    ]
  }
];

// Flatten all terms for flashcards/quiz
const allTerms = [];
glossaryData.forEach(cat => cat.terms.forEach(t => allTerms.push({ ...t, cat: cat.cat })));

// ===================== GLOSSARY =====================
function buildGlossary() {
  const el = document.getElementById('glossary-content');
  let html = '';
  glossaryData.forEach(cat => {
    html += `<div class="cat-header" style="border-color:${cat.color};color:${cat.color}">${cat.cat}</div>`;
    html += `<div class="glossary-grid">`;
    cat.terms.forEach((t, i) => {
      const id = `term-${cat.cat.replace(/\s/g,'')}-${i}`;
      html += `<div class="term-card" id="${id}" onclick="toggleTerm('${id}')">
        <div class="term-name">
          <span>${t.term}</span>
          <span style="display:flex;gap:0.5rem;align-items:center">
            <span class="term-tag" style="border-color:${cat.color};color:${cat.color}">${t.tag}</span>
            <span class="toggle-icon">+</span>
          </span>
        </div>
        <div class="term-def">
          ${t.def}
          ${t.example ? `<div class="term-example">üí° ${t.example}</div>` : ''}
        </div>
      </div>`;
    });
    html += `</div>`;
  });
  el.innerHTML = html;
}

function toggleTerm(id) {
  const el = document.getElementById(id);
  el.classList.toggle('open');
}

// ===================== FLASHCARDS =====================
let fcDeck = [...allTerms];
let fcIndex = 0;
let fcDone = 0;

function shuffleCards() {
  fcDeck = [...allTerms].sort(() => Math.random() - 0.5);
  fcIndex = 0;
  fcDone = 0;
  document.getElementById('flashcard').classList.remove('flipped');
  renderCard();
}

function renderCard() {
  const card = fcDeck[fcIndex];
  document.getElementById('fc-front').textContent = card.term;
  document.getElementById('fc-back').textContent = card.def;
  document.getElementById('fc-count').textContent = `Card ${fcIndex+1} of ${fcDeck.length}`;
  document.getElementById('fc-progress').style.width = `${((fcIndex+1)/fcDeck.length)*100}%`;
  document.getElementById('flashcard').classList.remove('flipped');
}

function flipCard() {
  document.getElementById('flashcard').classList.toggle('flipped');
}

function nextCard() {
  if (fcIndex < fcDeck.length - 1) { fcIndex++; renderCard(); }
}

function prevCard() {
  if (fcIndex > 0) { fcIndex--; renderCard(); }
}

function markCard(known) {
  if (known) {
    fcDone++;
    document.getElementById('stat-cards').textContent = fcDone;
  }
  nextCard();
}

// ===================== QUIZ =====================
let quizData = [];
let quizAnswered = 0;
let quizCorrect = 0;

const questionBank = [
  { q: "What is an algorithm?", a: "A finite and detailed step-by-step set of instructions performed to complete a specific task.", opts: ["A programming language", "A finite and detailed step-by-step set of instructions performed to complete a specific task.", "A type of computer hardware", "A software application"] },
  { q: "Which property states that an algorithm must always end after a finite number of steps?", a: "Finiteness", opts: ["Definiteness","Effectiveness","Finiteness","Input Specification"] },
  { q: "What does pseudocode mean?", a: "A generic way of describing an algorithm without using any specific programming language notations.", opts: ["Actual programming code", "A type of flowchart", "A generic way of describing an algorithm without using any specific programming language notations.", "Machine code instructions"] },
  { q: "Which data structure has the last node's link pointing back to the first node?", a: "Circularly Linked List", opts: ["Doubly Linked List", "Binary Tree", "Circularly Linked List", "Stack"] },
  { q: "In a Binary Search Tree, where are values smaller than the root placed?", a: "Left nodes", opts: ["Right nodes", "Left nodes", "Root node", "Any position"] },
  { q: "BFS stands for:", a: "Breadth First Search", opts: ["Binary First Search", "Broad Function Search", "Breadth First Search", "Branch File System"] },
  { q: "What technique breaks a problem into smaller subproblems, solves each recursively, then combines solutions?", a: "Divide and Conquer", opts: ["Brute Force", "Greedy Algorithm", "Divide and Conquer", "Dynamic Programming"] },
  { q: "Which graph has no direction (arrowhead) on its edges?", a: "Undirected Graph", opts: ["Directed Graph", "Digraph", "Undirected Graph", "Binary Tree"] },
  { q: "The Traveling Salesman Problem is an example of which type?", a: "Combinatorial Problem", opts: ["Sorting Problem", "Geometric Problem", "Combinatorial Problem", "String Processing Problem"] },
  { q: "What is Space Complexity?", a: "The amount of memory required by an algorithm to run the application.", opts: ["How fast an algorithm runs", "The amount of memory required by an algorithm to run the application.", "The number of steps in an algorithm", "The physical disk space needed"] },
  { q: "A node in a tree with an outdegree of zero is called:", a: "Leaf", opts: ["Root", "Internal Node", "Leaf", "Parent"] },
  { q: "Which tree type ensures height never exceeds O(log n)?", a: "AVL Tree", opts: ["Binary Tree", "Heap Tree", "AVL Tree", "General Tree"] },
  { q: "Approximate problem solving is used when:", a: "Some problems cannot be solved exactly or exact solutions are too slow.", opts: ["You always want exact results", "Some problems cannot be solved exactly or exact solutions are too slow.", "The problem is small", "You use brute force"] },
  { q: "The property that says algorithm steps must be precisely and unambiguously defined is:", a: "Definiteness", opts: ["Finiteness", "Definiteness", "Effectiveness", "Output Specification"] },
  { q: "From whose name does the word 'algorithm' originate?", a: "Muhammad ibn Musa al-Khwarizmi", opts: ["Ada Lovelace", "Alan Turing", "Muhammad ibn Musa al-Khwarizmi", "Charles Babbage"] },
  { q: "Which search algorithm examines data objects one by one sequentially?", a: "Linear Search", opts: ["Binary Search", "Linear Search", "Depth First Search", "Hash Search"] },
  { q: "What is the root of a tree?", a: "The first (topmost) node of the tree.", opts: ["Any leaf node", "The first (topmost) node of the tree.", "A node with no parent", "The node with highest degree"] },
  { q: "Which problem asks to find the smallest convex polygon enclosing all given points?", a: "Convex-Hull Problem", opts: ["Closest-Pair Problem", "Convex-Hull Problem", "Graph Coloring Problem", "TSP"] },
  { q: "DFS uses the concept of:", a: "Backtracking", opts: ["Layer-by-layer exploration", "Backtracking", "Binary splitting", "Greedy selection"] },
  { q: "In the 6-phase algorithm design process, which phase involves testing and debugging?", a: "Phase 6: Coding the Program", opts: ["Phase 1: Understanding the Problem", "Phase 3: Designing Algorithm", "Phase 5: Analyzing", "Phase 6: Coding the Program"] },
];

function buildQuiz() {
  // Pick 10 random questions
  quizData = [...questionBank].sort(() => Math.random() - 0.5).slice(0, 10);
  quizAnswered = 0;
  quizCorrect = 0;
  document.getElementById('quiz-result').classList.remove('show');
  document.getElementById('quiz-submit-btn').style.display = 'inline-block';

  let html = '';
  quizData.forEach((q, i) => {
    html += `<div class="quiz-q" id="qq-${i}">
      <div class="q-num">Question ${i+1} of 10</div>
      <div class="q-text">${q.q}</div>
      <div class="options">`;
    const shuffled = [...q.opts].sort(() => Math.random() - 0.5);
    shuffled.forEach((opt, j) => {
      html += `<button class="option-btn" id="opt-${i}-${j}" onclick="selectOption(${i},${j},'${opt.replace(/'/g,"\\'")}','${q.a.replace(/'/g,"\\'")}')">
        <span style="color:var(--accent3);margin-right:0.5rem;">${String.fromCharCode(65+j)}.</span> ${opt}
      </button>`;
    });
    html += `</div>
      <div class="feedback-box" id="fb-${i}"></div>
    </div>`;
  });
  document.getElementById('quiz-content').innerHTML = html;
}

function selectOption(qi, oi, selected, correct) {
  const qEl = document.getElementById(`qq-${qi}`);
  if (qEl.dataset.answered) return;
  qEl.dataset.answered = '1';
  quizAnswered++;

  const opts = qEl.querySelectorAll('.option-btn');
  opts.forEach(b => b.disabled = true);

  const isCorrect = selected === correct;
  if (isCorrect) quizCorrect++;

  opts.forEach((b, i) => {
    const txt = b.textContent.trim().substring(2).trim();
    if (txt === correct) b.classList.add('correct');
    if (i === oi && !isCorrect) b.classList.add('wrong');
  });

  const fb = document.getElementById(`fb-${qi}`);
  fb.classList.add('show');
  if (isCorrect) {
    fb.classList.add('ok');
    fb.textContent = '‚úì Correct!';
  } else {
    fb.classList.add('bad');
    fb.textContent = `‚úó Incorrect. The correct answer is: ${correct}`;
  }

  // Update stat
  document.getElementById('stat-quiz').textContent = `${quizCorrect}/${quizAnswered}`;
}

function submitQuiz() {
  document.getElementById('quiz-result').classList.add('show');
  document.getElementById('quiz-submit-btn').style.display = 'none';
  const pct = Math.round((quizCorrect / 10) * 100);
  document.getElementById('quiz-score-display').textContent = `${quizCorrect}/10`;
  let verdict, msg;
  if (pct >= 90) { verdict = "üèÜ Outstanding!"; msg = "You're fully prepared. Aces!"; }
  else if (pct >= 75) { verdict = "‚úÖ Great job!"; msg = "Solid understanding. Review missed items."; }
  else if (pct >= 60) { verdict = "üìö Passing"; msg = "Keep reviewing‚Äîfocus on weak spots."; }
  else { verdict = "‚ö†Ô∏è Needs more study"; msg = "Go back to the Glossary and Flashcards!"; }
  document.getElementById('quiz-verdict').textContent = verdict;
  document.getElementById('quiz-msg').textContent = msg;
  document.getElementById('stat-quiz').textContent = `${quizCorrect}/10`;
}

function resetQuiz() {
  buildQuiz();
}

// ===================== MATCHING GAME =====================
const matchPairs = [
  { term: "Algorithm", def: "Finite step-by-step instructions for a task" },
  { term: "Finiteness", def: "Algorithm must end after finite steps" },
  { term: "Definiteness", def: "Steps must be unambiguous for every case" },
  { term: "Brute Force", def: "Straightforward approach; best for small instances" },
  { term: "Divide & Conquer", def: "Break into subproblems, solve, combine" },
  { term: "Leaf Node", def: "Tree node with outdegree of zero" },
  { term: "AVL Tree", def: "BST with height never exceeding O(log n)" },
  { term: "DFS", def: "Recursive graph traversal using backtracking" },
  { term: "TSP", def: "Shortest tour visiting every city once" },
  { term: "Heap Tree", def: "Used to implement priority queues" },
];

let selectedTerm = null;
let selectedDef = null;
let matchedCount = 0;
let currentPairs = [];

function resetMatch() {
  selectedTerm = null;
  selectedDef = null;
  matchedCount = 0;
  document.getElementById('match-score').textContent = '';

  currentPairs = [...matchPairs].sort(() => Math.random() - 0.5).slice(0, 7);
  const shuffledDefs = [...currentPairs].sort(() => Math.random() - 0.5);

  let termsHtml = '';
  currentPairs.forEach((p, i) => {
    termsHtml += `<div class="match-item" id="mt-${i}" onclick="selectMatchTerm(${i},'${p.term.replace(/'/g,"\\'")}')">
      ${p.term}
    </div>`;
  });

  let defsHtml = '';
  shuffledDefs.forEach((p, i) => {
    defsHtml += `<div class="match-item" id="md-${i}" onclick="selectMatchDef(${i},'${p.term.replace(/'/g,"\\'")}','${p.def.replace(/'/g,"\\'")}')">
      ${p.def}
    </div>`;
  });

  document.getElementById('match-terms').innerHTML = termsHtml;
  document.getElementById('match-defs').innerHTML = defsHtml;
}

function selectMatchTerm(idx, term) {
  const el = document.getElementById(`mt-${idx}`);
  if (el.classList.contains('matched-ok')) return;

  // Deselect previous
  document.querySelectorAll('.match-item.selected').forEach(e => {
    if (!e.id.startsWith('md-')) e.classList.remove('selected');
  });

  selectedTerm = { idx, term, el };
  el.classList.add('selected');
  checkMatch();
}

function selectMatchDef(idx, correctTerm, def) {
  const el = document.getElementById(`md-${idx}`);
  if (el.classList.contains('matched-ok')) return;

  document.querySelectorAll('.match-item.selected').forEach(e => {
    if (e.id.startsWith('md-')) e.classList.remove('selected');
  });

  selectedDef = { idx, correctTerm, def, el };
  el.classList.add('selected');
  checkMatch();
}

function checkMatch() {
  if (!selectedTerm || !selectedDef) return;
  if (selectedTerm.term === selectedDef.correctTerm) {
    selectedTerm.el.classList.remove('selected');
    selectedTerm.el.classList.add('matched-ok');
    selectedTerm.el.onclick = null;
    selectedDef.el.classList.remove('selected');
    selectedDef.el.classList.add('matched-ok');
    selectedDef.el.onclick = null;
    matchedCount++;
    if (matchedCount === currentPairs.length) {
      document.getElementById('match-score').textContent = 'üéâ Perfect Round! All matched!';
    } else {
      document.getElementById('match-score').textContent = `${matchedCount}/${currentPairs.length} matched`;
    }
  } else {
    selectedTerm.el.classList.add('matched-bad');
    selectedDef.el.classList.add('matched-bad');
    setTimeout(() => {
      selectedTerm.el.classList.remove('selected','matched-bad');
      selectedDef.el.classList.remove('selected','matched-bad');
    }, 800);
  }
  selectedTerm = null;
  selectedDef = null;
}

// ===================== CHEAT SHEET =====================
const cheatData = [
  {
    title: "5 Properties of an Algorithm",
    rows: [
      { k: "Input Specification", v: "0 or more clearly identified inputs from specified set" },
      { k: "Output Specification", v: "At least 1 output; relationship to input clearly stated" },
      { k: "Definiteness", v: "Steps are precise & unambiguous for every case" },
      { k: "Finiteness", v: "Always ends after finite steps & resources" },
      { k: "Effectiveness", v: "All operations basic enough to do exactly in finite time" },
    ]
  },
  {
    title: "6 Phases of Algorithm Design",
    rows: [
      { k: "Phase 1", v: "Understand the problem completely (inputs, outputs, constraints)" },
      { k: "Phase 2", v: "Decide on computational device, data structures, design technique" },
      { k: "Phase 3", v: "Design the algorithm and choose data structure" },
      { k: "Phase 4", v: "Prove correctness (mathematical induction)" },
      { k: "Phase 5", v: "Analyze: efficiency (time & space), simplicity, generality" },
      { k: "Phase 6", v: "Code and implement; validate via testing & debugging" },
    ]
  },
  {
    title: "Data Structures Quick Reference",
    rows: [
      { k: "Array", v: "Fixed size; same data type; fast index access; less memory" },
      { k: "Linked List", v: "Dynamic size; nodes with data + pointer" },
      { k: "Singly LL", v: "Pointer to next only; insertion/deletion O(1)" },
      { k: "Doubly LL", v: "Pointer to next AND prev; reversible iteration" },
      { k: "Circular LL", v: "Last node ‚Üí first node; used in buffers, games, undo" },
      { k: "Graph", v: "Nodes + edges; directed (arcs, one-way) or undirected (two-way)" },
      { k: "Binary Tree", v: "Max 2 children per node" },
      { k: "BST", v: "Left < Root ‚â§ Right; memory-efficient; supports range search" },
      { k: "AVL Tree", v: "Balanced BST; height = O(log n)" },
      { k: "Heap Tree", v: "Complete binary tree; parent key ‚â• children; used in priority queue" },
    ]
  },
  {
    title: "Problem Types",
    rows: [
      { k: "Sorting", v: "Rearrange in ascending order; enables faster searching" },
      { k: "Searching", v: "Find a key; linear (one by one) or binary (halving)" },
      { k: "String Processing", v: "Text, bit, or gene sequence strings" },
      { k: "Graph Problems", v: "BFS (layer-by-layer) / DFS (backtracking)" },
      { k: "Combinatorial", v: "TSP (shortest city tour) / Graph Coloring (no same-color neighbors)" },
      { k: "Geometrical", v: "Closest-pair / Convex-hull" },
      { k: "Numerical", v: "Equations, integrals, continuous math objects" },
    ]
  },
  {
    title: "Pseudocode Keywords",
    rows: [
      { k: "INPUT", v: "User provides a value" },
      { k: "OUTPUT", v: "Display result on screen" },
      { k: "IF-THEN-ELSE", v: "Decision / selection (with indentation)" },
      { k: "FOR", v: "Counting loop (iteration)" },
      { k: "WHILE", v: "Loop with condition at the beginning" },
      { k: "REPEAT-UNTIL", v: "Loop with condition at the end" },
    ]
  },
  {
    title: "Algorithm Analysis Qualities",
    rows: [
      { k: "Time Complexity", v: "Measures how fast algorithm runs" },
      { k: "Space Complexity", v: "Measures memory used" },
      { k: "Simplicity", v: "Fewer bugs; easier to understand; sometimes more efficient" },
      { k: "Generality", v: "Range of problems and inputs it can handle" },
    ]
  },
];

function buildCheat() {
  let html = '';
  cheatData.forEach((sec, i) => {
    const id = `cheat-${i}`;
    html += `<div class="cheat-section">
      <div class="cheat-header" onclick="toggleCheat('${id}')">
        <span>${sec.title}</span>
        <span id="${id}-icon">‚ñº</span>
      </div>
      <div class="cheat-body" id="${id}">`;
    sec.rows.forEach(r => {
      html += `<div class="cheat-row">
        <div class="key">${r.k}</div>
        <div class="val">${r.v}</div>
      </div>`;
    });
    html += `</div></div>`;
  });
  document.getElementById('cheat-content').innerHTML = html;
}

function toggleCheat(id) {
  const el = document.getElementById(id);
  const icon = document.getElementById(id+'-icon');
  const open = el.classList.toggle('open');
  icon.textContent = open ? '‚ñ≤' : '‚ñº';
}

// ===================== TAB SWITCHING =====================
function switchTab(name) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.getElementById(`sec-${name}`).classList.add('active');
  event.target.classList.add('active');
}

// ===================== INIT =====================
buildGlossary();
shuffleCards();
buildQuiz();
resetMatch();
buildCheat();
</script>
</body>
</html>